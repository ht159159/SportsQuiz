{"remainingRequest":"C:\\work\\竞猜可换色板\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\work\\竞猜可换色板\\src\\components\\roundTurntable.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\work\\竞猜可换色板\\src\\components\\roundTurntable.vue","mtime":1604631041679},{"path":"C:\\work\\竞猜可换色板\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\work\\竞猜可换色板\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\work\\竞猜可换色板\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\work\\竞猜可换色板\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\work\\竞猜可换色板\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexport default {\n  name: \"round-turntable\",\n  Mounted() {\n    this.init();\n  },\n  props: {\n    prizeData: {\n      required: true\n    },\n    rotateCircle: {\n      default: 6\n    },\n    turntableStyleOption: {\n      default: () => {\n        return {\n          // 背景色\n          prizeBgColors: [\n            \"#AE3EFF\",\n            \"#4D3FFF\",\n            \"#FC262C\",\n            \"#3A8BFF\",\n            \"#EE7602\",\n            \"#FE339F\"\n          ],\n          // 转盘的外边框颜色\n          borderColor: \"#199301\"\n        };\n      }\n    },\n    duringTime: {\n      default: 4.5\n    }\n  },\n  data() {\n    return {\n      // 开始转动的角度\n      startRotateDegree: 0,\n      rotateAngle: 0,\n      rotateTransition: \"\"\n    };\n  },\n  methods: {\n    // 根据index计算每一格要旋转的角度的样式\n    getRotateAngle(index) {\n      const angle =\n        (360 / this.prizeData.length) * index + 180 / this.prizeData.length;\n      return {\n        transform: `rotate(${angle}deg)`\n      };\n    },\n    // 初始化圆形转盘canvas\n    init() {\n      // 各种数据\n      const data = this.turntableStyleOption;\n      const prizeNum = this.prizeData.length;\n      const { prizeBgColors, borderColor } = data;\n      // 开始绘画\n      const canvas = this.$refs.canvas;\n      const ctx = canvas.getContext(\"2d\");\n      const canvasW = (this.$refs.canvas.width = this.$refs.turntable.clientWidth); // 画板的高度\n      const canvasH = (this.$refs.canvas.height = this.$refs.turntable.clientHeight); // 画板的宽度\n      // translate方法重新映射画布上的 (0,0) 位置\n      ctx.translate(0, canvasH);\n      // rotate方法旋转当前的绘图，因为文字适合当前扇形中心线垂直的！\n      ctx.rotate((-90 * Math.PI) / 180);\n      // 圆环的外圆的半径\n      const outRadius = canvasW / 2;\n      // 圆环的内圆的半径\n      const innerRadius = 0;\n      const baseAngle = (Math.PI * 2) / prizeNum; // 计算每个奖项所占角度数\n      ctx.clearRect(0, 0, canvasW, canvasH); //去掉背景默认的黑色\n      ctx.strokeStyle = borderColor; // 设置画图线的颜色\n      for (let index = 0; index < prizeNum; index++) {\n        const angle = index * baseAngle;\n        ctx.fillStyle = prizeBgColors[index]; //设置每个扇形区域的颜色\n        ctx.beginPath(); //开始绘制\n        // 标准圆弧：arc(x,y,radius,startAngle,endAngle,anticlockwise)\n        ctx.arc(\n          canvasW * 0.5,\n          canvasH * 0.5,\n          outRadius,\n          angle,\n          angle + baseAngle,\n          false\n        );\n        ctx.arc(\n          canvasW * 0.5,\n          canvasH * 0.5,\n          innerRadius,\n          angle + baseAngle,\n          angle,\n          true\n        );\n        ctx.stroke(); //开始链线\n        ctx.fill(); //填充颜色\n        ctx.save(); //保存当前环境的状态\n      }\n    },\n    // 转动起来\n    rotate(index) {\n      // 运转时长\n      const duringTime = this.duringTime;\n      const rotateAngle =\n        this.startRotateDegree +\n        this.rotateCircle * 360 +\n        360 -\n        (180 / this.prizeData.length + (360 / this.prizeData.length) * index) -\n        (this.startRotateDegree % 360);\n      this.startRotateDegree = rotateAngle;\n      this.rotateAngle = `rotate(${rotateAngle}deg)`;\n      this.rotateTransition = `transform ${duringTime}s cubic-bezier(0.250, 0.460, 0.455, 0.995)`;\n      setTimeout(() => {\n        this.$emit(\"endRotation\");\n      }, duringTime * 1000 + 500);\n    }\n  }\n};\n",null]}